"""Analytics Service for tracking user actions and conversion funnel metrics."""\n\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Optional\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import func, and_\nfrom app.models.analytics import UserAction, ConversionMetric, Alert\nfrom app.models.user import User\n\n\nclass AnalyticsService:\n    \"\"\"Service for analytics and conversion funnel tracking.\"\"\"\n\n    @staticmethod\n    def track_user_action(\n        db: Session,\n        user_id: int,\n        action_type: str,\n        action_details: Optional[Dict] = None,\n    ) -> UserAction:\n        \"\"\"\n        Track a user action for analytics.\n\n        Args:\n            db: Database session\n            user_id: ID of the user performing the action\n            action_type: Type of action (e.g., 'first_message_sent', 'contract_signed')\n            action_details: Optional additional details about the action\n\n        Returns:\n            UserAction object\n        \"\"\"\n        user_action = UserAction(\n            user_id=user_id,\n            action_type=action_type,\n            action_details=action_details or {},\n            timestamp=datetime.utcnow(),\n        )\n        db.add(user_action)\n        db.commit()\n        db.refresh(user_action)\n        return user_action\n\n    @staticmethod\n    def get_onboarding_completion_rate(db: Session, days: int = 7) -> Dict:\n        \"\"\"\n        Calculate the onboarding completion rate.\n\n        Metrics:\n        - Total new users in the period\n        - Users who sent first message\n        - Completion rate percentage\n\n        Args:\n            db: Database session\n            days: Number of days to look back\n\n        Returns:\n            Dictionary with completion metrics\n        \"\"\"\n        cutoff_date = datetime.utcnow() - timedelta(days=days)\n\n        # Count new users\n        new_users = db.query(func.count(User.id)).filter(\n            User.created_at >= cutoff_date\n        ).scalar()\n\n        # Count users who sent first message\n        users_sent_message = db.query(func.count(func.distinct(UserAction.user_id))).filter(\n            and_(\n                UserAction.action_type == 'first_message_sent',\n                UserAction.timestamp >= cutoff_date,\n            )\n        ).scalar()\n\n        completion_rate = (\n            (users_sent_message / new_users * 100) if new_users > 0 else 0\n        )\n\n        return {\n            'total_new_users': new_users,\n            'users_sent_first_message': users_sent_message,\n            'completion_rate': round(completion_rate, 2),\n            'period_days': days,\n        }\n\n    @staticmethod\n    def get_feature_adoption_rate(db: Session, feature: str, days: int = 7) -> Dict:\n        \"\"\"\n        Calculate the adoption rate for a specific feature.\n\n        Args:\n            db: Database session\n            feature: Feature name (e.g., 'blockchain_contract', 'order_management')\n            days: Number of days to look back\n\n        Returns:\n            Dictionary with adoption metrics\n        \"\"\"\n        cutoff_date = datetime.utcnow() - timedelta(days=days)\n\n        # Count total active users\n        total_active_users = db.query(func.count(func.distinct(UserAction.user_id))).filter(\n            UserAction.timestamp >= cutoff_date\n        ).scalar()\n\n        # Count users who adopted the feature\n        feature_adopters = db.query(func.count(func.distinct(UserAction.user_id))).filter(\n            and_(\n                UserAction.action_type == f'{feature}_created',\n                UserAction.timestamp >= cutoff_date,\n            )\n        ).scalar()\n\n        adoption_rate = (\n            (feature_adopters / total_active_users * 100) if total_active_users > 0 else 0\n        )\n\n        return {\n            'feature': feature,\n            'total_active_users': total_active_users,\n            'feature_adopters': feature_adopters,\n            'adoption_rate': round(adoption_rate, 2),\n            'period_days': days,\n        }\n\n    @staticmethod\n    def get_conversion_funnel(db: Session, days: int = 7) -> Dict:\n        \"\"\"\n        Get the complete conversion funnel metrics.\n\n        Funnel stages:\n        1. New users\n        2. Users who sent first message\n        3. Users who completed meeting\n        4. Users who created contract\n        5. Users who processed payment\n\n        Args:\n            db: Database session\n            days: Number of days to look back\n\n        Returns:\n            Dictionary with funnel metrics\n        \"\"\"\n        cutoff_date = datetime.utcnow() - timedelta(days=days)\n\n        # Stage 1: New users\n        new_users = db.query(func.count(User.id)).filter(\n            User.created_at >= cutoff_date\n        ).scalar()\n\n        # Stage 2: First message sent\n        first_message = db.query(func.count(func.distinct(UserAction.user_id))).filter(\n            and_(\n                UserAction.action_type == 'first_message_sent',\n                UserAction.timestamp >= cutoff_date,\n            )\n        ).scalar()\n\n        # Stage 3: Meeting completed\n        meeting_completed = db.query(func.count(func.distinct(UserAction.user_id))).filter(\n            and_(\n                UserAction.action_type == 'meeting_completed',\n                UserAction.timestamp >= cutoff_date,\n            )\n        ).scalar()\n\n        # Stage 4: Contract signed\n        contract_signed = db.query(func.count(func.distinct(UserAction.user_id))).filter(\n            and_(\n                UserAction.action_type == 'contract_signed',\n                UserAction.timestamp >= cutoff_date,\n            )\n        ).scalar()\n\n        # Stage 5: Payment processed\n        payment_processed = db.query(func.count(func.distinct(UserAction.user_id))).filter(\n            and_(\n                UserAction.action_type == 'payment_processed',\n                UserAction.timestamp >= cutoff_date,\n            )\n        ).scalar()\n\n        # Calculate drop-off rates\n        funnel_stages = [\n            {'stage': 'New Users', 'count': new_users, 'percentage': 100},\n            {\n                'stage': 'First Message Sent',\n                'count': first_message,\n                'percentage': round((first_message / new_users * 100) if new_users > 0 else 0, 2),\n            },\n            {\n                'stage': 'Meeting Completed',\n                'count': meeting_completed,\n                'percentage': round(\n                    (meeting_completed / new_users * 100) if new_users > 0 else 0, 2\n                ),\n            },\n            {\n                'stage': 'Contract Signed',\n                'count': contract_signed,\n                'percentage': round(\n                    (contract_signed / new_users * 100) if new_users > 0 else 0, 2\n                ),\n            },\n            {\n                'stage': 'Payment Processed',\n                'count': payment_processed,\n                'percentage': round(\n                    (payment_processed / new_users * 100) if new_users > 0 else 0, 2\n                ),\n            },\n        ]\n\n        return {\n            'period_days': days,\n            'funnel_stages': funnel_stages,\n        }\n\n    @staticmethod\n    def get_drop_off_points(db: Session, days: int = 7, threshold: float = 30.0) -> List[Dict]:\n        \"\"\"\n        Identify drop-off points where abandonment exceeds threshold.\n\n        Args:\n            db: Database session\n            days: Number of days to look back\n            threshold: Drop-off percentage threshold (default 30%)\n\n        Returns:\n            List of drop-off points\n        \"\"\"\n        funnel = AnalyticsService.get_conversion_funnel(db, days)\n        drop_off_points = []\n\n        stages = funnel['funnel_stages']\n        for i in range(len(stages) - 1):\n            current_percentage = stages[i]['percentage']\n            next_percentage = stages[i + 1]['percentage']\n            drop_off = current_percentage - next_percentage\n\n            if drop_off >= threshold:\n                drop_off_points.append({\n                    'from_stage': stages[i]['stage'],\n                    'to_stage': stages[i + 1]['stage'],\n                    'drop_off_percentage': round(drop_off, 2),\n                    'users_lost': stages[i]['count'] - stages[i + 1]['count'],\n                })\n\n        return drop_off_points\n\n    @staticmethod\n    def create_alert(\n        db: Session,\n        metric_name: str,\n        threshold: float,\n        current_value: float,\n        alert_type: str = 'critical',\n    ) -> Alert:\n        \"\"\"\n        Create an alert when a metric exceeds threshold.\n\n        Args:\n            db: Database session\n            metric_name: Name of the metric (e.g., 'drop_off_rate')\n            threshold: Alert threshold\n            current_value: Current value of the metric\n            alert_type: Type of alert ('critical', 'warning', 'info')\n\n        Returns:\n            Alert object\n        \"\"\"\n        alert = Alert(\n            metric_name=metric_name,\n            threshold=threshold,\n            current_value=current_value,\n            alert_type=alert_type,\n            message=f'{metric_name} has exceeded threshold: {current_value}% (threshold: {threshold}%)',\n            created_at=datetime.utcnow(),\n            is_resolved=False,\n        )\n        db.add(alert)\n        db.commit()\n        db.refresh(alert)\n        return alert\n\n    @staticmethod\n    def get_active_alerts(db: Session) -> List[Alert]:\n        \"\"\"\n        Get all unresolved alerts.\n\n        Args:\n            db: Database session\n\n        Returns:\n            List of active alerts\n        \"\"\"\n        return db.query(Alert).filter(Alert.is_resolved == False).all()\n\n    @staticmethod\n    def resolve_alert(db: Session, alert_id: int) -> Alert:\n        \"\"\"\n        Mark an alert as resolved.\n\n        Args:\n            db: Database session\n            alert_id: ID of the alert to resolve\n\n        Returns:\n            Updated alert object\n        \"\"\"\n        alert = db.query(Alert).filter(Alert.id == alert_id).first()\n        if alert:\n            alert.is_resolved = True\n            alert.resolved_at = datetime.utcnow()\n            db.commit()\n            db.refresh(alert)\n        return alert\n
